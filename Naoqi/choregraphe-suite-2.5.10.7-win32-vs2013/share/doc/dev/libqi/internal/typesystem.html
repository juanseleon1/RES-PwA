<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Type system &mdash; Aldebaran 2.5.9.8-r3 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '2.5.9.8-r3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="Aldebaran 2.5.9.8-r3 documentation" href="../../../index.html" />
    <link rel="up" title="qi Framework" href="../index.html" />
    <link rel="next" title="Object type erasure" href="object.html" />
    <link rel="prev" title="Coding Convention" href="../design/codingstyle.html" />
 
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-115894784-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-115894784-1');
</script>

<script type="text/javascript" src="https://cloud.aldebaran-robotics.com/static/js/topbar.js"></script>
<style>
div#hd::after {
  
  
  content: 'NAOqi 2.5';
  
  
  
  position: absolute;
  margin-top: -54px;
  right: -4px;
  font-size: 125%;
  -webkit-transform: rotate(45deg);
  -moz-transform: rotate(45deg);
  -o-transform: rotate(45deg);
  transform: rotate(45deg);
  }
</style>
<script>

$(window).ready(function () {

    //Aldebaran Top bar
     var barLinks = [];
     barLinks.push({'name':'Aldebaran Site', 'url':'http://www.aldebaran-robotics.com', 'click':'', 'img':'https://cloud.aldebaran-robotics.com/static/img/aldeb.png'});
     barLinks.push({'name':'Documentation', 'url':'../../../index.html', 'click':"", 'img':''});
     function ShowBar(name, email, usertype) {
        var barParams = {
            'name'    : name,
            'email'   : email,
            'usertype': usertype,
            'loginfct': "FctLogin"
        }
        try { InitTopBar(barParams, barLinks); } catch (e) { console.log('Top Bar Init Failed'); }
    }
    ShowBar();

    var width_label = 0;
    $('dl.function-index dt > span').each(function () {
        $(this).css('width', 'auto');
        width_label = Math.max(width_label, $(this).width());
    }).width(width_label + 30);
    $('.sig-paren').width('auto');

    // first level navigation

    var buttonIds = [".naoqi", "pepper", "nao", "romeo"];
    for(id in buttonIds){
        $(id).removeClass("active");
    }
    //Aldebaran project
    if ($('.toctree-l1.current a').text().indexOf("Romeo ")==0){
        $(".romeo").toggleClass('active');
    }
    else if ($('.toctree-l1.current a').text().indexOf("Pepper ")==0){
        $(".pepper").toggleClass('active');
    }
    else if ($('.toctree-l1.current a').text().indexOf("NAO ")==0){
        $(".nao").toggleClass('active');
    }
    else if($('.toctree-l1.current a').text().indexOf("NAOqi ")==0){
        $(".naoqi").toggleClass('active');
    }

    //qibuild project
    if ($('.toctree-l1.current a').text().indexOf("Welcome to qiBuild documentation !")==0){
        $(".beginner").toggleClass('active');
    }
    else if ($('.toctree-l1.current a').text().indexOf("Advanced qibuild usage")==0){
        $(".advanced").toggleClass('active');
    }
    else if ($('.toctree-l1.current a').text().indexOf("Hacking qiBuild")==0){
        $(".hacking").toggleClass('active');
    }

    // add "On this page", add cssClasses
    if($('.yui-g .section h1').length > 0){
        $('.yui-g .section h1:first').addClass("titleWrapper");
        $('.yui-g .section h1:first').after($("#on-this-page").html())
    }
    else if($('.yui-g .section h2').length > 0){
        $('.yui-g .section h2:first').addClass("titleWrapper");
        $('.yui-g .section h2:first').after($("#on-this-page").html())
    }
    //remove first element on this page
    if($("#on-this-page").length > 0){
        var doms = $(".yui-g .section :first").nextUntil("#toc-list");
        doms = doms.add($("#toc-list"));
        doms.wrapAll('<div class="iNavWrapper"></div>');
        $("#toc-list ul li a:first").remove()
        $("#toc-list ul:first").replaceWith($("#toc-list ul li").html())
    }
    $("#toc-list").hide();
    $("#otp-link").click(function(){
        $("#toc-list").slideToggle();
        if($("h2#otp-link").hasClass("change-before")){
            $("h2#otp-link").removeClass("change-before")
        }
        else{
            $("h2#otp-link").addClass("change-before")
        }
    });

    if($("a.current.reference.internal").length>0){
        var left = $("a.current.reference.internal").position().left-1;
        var width = $("a.current.reference.internal").width();
        var offset = 51;
        var sidebarWidth = 339;
        var right = sidebarWidth - (left + width + offset);
        if($("a.current.reference.internal").height() <= 15){
            $("a.current.reference.internal").css("white-space","nowrap");
            $("a.current.reference.internal").css({"backgroundColor":"#0F2939","paddingTop":"2px", "paddingBottom":"2px","paddingLeft":left+"px","marginLeft":"-"+left+"px", "paddingRight":right+"px","marginRight":"-"+right+"px", "boxShadow":"0px 0px 1px rgb(15, 41, 57)"});
        }
        else{
            $("a.current.reference.internal").css({"float":"right","backgroundColor":"#0F2939","paddingTop":"2px", "paddingBottom":"2px","paddingLeft":left+"px","marginLeft":"-"+left+"px", "paddingRight":right+"px","marginRight":"-"+right+"px", "boxShadow":"0px 0px 1px rgb(15, 41, 57)"});
            left = $("a.current.reference.internal").position().left-1;
            width = $("a.current.reference.internal").width();
            right = sidebarWidth - (left + width + offset);
            $("a.current.reference.internal").css({"float":"right","backgroundColor":"#0F2939","paddingTop":"2px", "paddingBottom":"2px","paddingLeft":left+"px","marginLeft":"-"+left+"px", "paddingRight":right+"px","marginRight":"-"+right+"px", "boxShadow":"0px 0px 1px rgb(15, 41, 57)"});
        }
        $("a.current.reference.internal").parent().css("list-style-type","none");
    }

    //back to top
    var offset = 300,
    //browser window scroll (in pixels) after which the "back to top" link opacity is reduced
    offset_opacity = 1200,
    //duration of the top scrolling animation (in ms)
    scroll_top_duration = 700;
    //grab the "back to top" link
    var back_to_top = $('.cd-top');

    //hide or show the "back to top" link
    $(window).scroll(function(){
        //back to top button
        ( $(this).scrollTop() > offset ) ? back_to_top.addClass('cd-is-visible') : back_to_top.removeClass('cd-is-visible cd-fade-out');
        if( $(this).scrollTop() > offset_opacity ) {
            back_to_top.addClass('cd-fade-out');
        }
    });

    //smooth scroll to top
    back_to_top.click(function(event){
        event.preventDefault();
        $('body,html').animate({
            scrollTop: 0 ,
        }, scroll_top_duration
        );
    });
    //add show source button

    //replace "go" with "search"
    $("#searchbox form input[type=submit]").val("Search")

    //trigger click on version triangle to jump to whats new
    $("#hd").click(function(e){if(e.pageX >= this.offsetWidth && e.pageY<120){$(".whatsnew")[0].click()}})
})

</script>


  </head>
  <body role="document">

    <div class="document">
  <div id="custom-doc" class="yui-t3">
    <div id="hd">
      
      <h1><a href="../../../index.html">SoftBank Robotics documentation</a>
      
      
      <span><a class="whatsnew" href="../../../news/index.html" >
      
          What's new in NAOqi 2.5?
      
      </a></span>
      
      </h1>
      <div id="global-nav">
        
        <a class="naoqi" title="NAOqi Developer guide" href="../../../index_dev_guide.html">NAOqi</a>
        <a class="pepper" title="Pepper documentation" href="../../../home_pepper.html">Pepper</a>
        <a class="nao" title="NAO documentation" href="../../../home_nao.html">NAO</a>
        <a class="romeo" title="Romeo Documentation" href="../../../home_romeo.html">Romeo</a>
        
        
        
        <div class="nav">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script></div>
      </div>

    </div>
    <main class="cd-container">
        <div id="bd">
          <div id="yui-main">
            <div class="yui-b">
              <div class="yui-g" id="dev-libqi-internal-typesystem">
                
  <div class="section" id="type-system">
<span id="internal-typesystem"></span><h1>Type system<a class="headerlink" href="#type-system" title="Permalink to this headline">¶</a></h1>
<p>libqi does type erasure in similar way to Python. A type erased value is
composed of a <code class="docutils literal"><span class="pre">void*</span></code> and a <code class="docutils literal"><span class="pre">TypeInterface*</span></code> (see <code class="docutils literal"><span class="pre">AnyReferenceBase</span></code>).
The <code class="xref cpp cpp-guess docutils literal"><span class="pre">TypeInterface</span></code> class is abstract and has a <code class="docutils literal"><span class="pre">kind()</span></code> method which returns
an enum value.</p>
<p>To each kind corresponds a <code class="xref cpp cpp-guess docutils literal"><span class="pre">TypeInterface</span></code>, like <code class="xref cpp cpp-guess docutils literal"><span class="pre">ListTypeInterface</span></code>,
<code class="xref cpp cpp-guess docutils literal"><span class="pre">ObjectTypeInterface</span></code>, etc. A value can&#8217;t be of multiple kinds. The list of all
kinds is in <strong>fwd.hpp</strong> and their mapping in signatures is in
<strong>signature.hpp</strong>.</p>
<p>This system allows a value to hold anything, for example a PyObject
representing an integer. This PyObject will not be converted to a C++ integer
until it is needed. Note that it may be never needed if the value is passed
back to Python code.</p>
<p>Type interfaces usually exist as unique instances within the program. This is
not enforced though and it may happen that a type interface exist multiple
times within a single program.</p>
<p>Type interfaces should be stateless, this is not enforced though and their
functions are not marked <code class="docutils literal"><span class="pre">const</span></code>.</p>
<div class="section" id="about-kinds">
<h2>About kinds<a class="headerlink" href="#about-kinds" title="Permalink to this headline">¶</a></h2>
<p>A value of type <em>Unknown</em> cannot be used in a type-erased context. Its only
use is when you use an unregistered type to do a type-erased call, if you give
a type T and your function takes exactly a type T (the <code class="docutils literal"><span class="pre">std::type_info</span></code> must
be equal), then the type system uses it as an <em>Unknown</em> value, but the call
succeeds because the value is not transformed. You have the same behavior if
you do <code class="docutils literal"><span class="pre">qi::AnyValue::from(someT)</span></code> and then <code class="docutils literal"><span class="pre">yourvalue.as&lt;T&gt;()</span></code>.</p>
<p>A value of type <em>Pointer</em> is a typed pointer, it can be a raw pointer or a
shared pointer. If it is a raw pointer, libqi does nothing to manage its
lifetime, it&#8217;s up to the user to handle that.</p>
<p>A value of type <em>Dynamic</em> is an untyped pointer. There is no such thing in
C++, but you can see it as <code class="docutils literal"><span class="pre">boost::any</span></code>. It is used to type-erase
<code class="docutils literal"><span class="pre">PyObject</span></code>.</p>
<p>You can look at the interfaces of <code class="xref cpp cpp-guess docutils literal"><span class="pre">PointerTypeInterface</span></code> and
<code class="xref cpp cpp-guess docutils literal"><span class="pre">DynamicTypeInterface</span></code> in <strong>typeinterface.hpp</strong>. <code class="xref cpp cpp-guess docutils literal"><span class="pre">PointerTypeInterface</span></code> returns
a static type that does not depends on the value (the <code class="docutils literal"><span class="pre">pointedType</span></code> function
does not take the <code class="docutils literal"><span class="pre">void*</span></code> as argument), but the <code class="xref cpp cpp-guess docutils literal"><span class="pre">DynamicTypeInterface</span></code> can
return types different for each value through the <code class="xref cpp cpp-guess docutils literal"><span class="pre">get</span></code> method.</p>
<p>A value of type <em>Tuple</em>, as the name suggests, is a list of values of
different, fixed, types. Same as <code class="docutils literal"><span class="pre">std::tuple</span></code> in C++. C++ structures are
represented as annotated tuples (the annotations correspond to the name of the
structure and the name of its fields).</p>
<p>A value of type <em>Raw</em> is a raw buffer, conceptually like a <code class="docutils literal"><span class="pre">std::vector&lt;char&gt;</span></code>
or a <code class="docutils literal"><span class="pre">std::pair&lt;char*,</span> <span class="pre">size_t&gt;</span></code>. <a class="reference internal" href="../api/cpp/type/buffer.html#qi::Buffer" title="qi::Buffer"><code class="xref cpp cpp-guess docutils literal"><span class="pre">qi::Buffer</span></code></a> is implemented as <em>Raw</em>. This
type is different from <code class="docutils literal"><span class="pre">std::vector&lt;char&gt;</span></code> which is a <em>List</em> of <em>Int8</em>. A
<em>List</em> is something that gets introspected and that can be heterogeneous, a
<em>Raw</em> is just a buffer of untyped data.</p>
<p>A value of type <em>VarArgs</em> is a variadic argument. Such object has single
type, and any number of objects of that type. You can see it as Java&#8217;s variadic
function which look like <code class="docutils literal"><span class="pre">void</span> <span class="pre">f(String...</span> <span class="pre">strArray)</span></code>. If you need different
types, you can use a <em>VarArgs</em> of <em>Dynamic</em>.</p>
</div>
<div class="section" id="relation-between-types-and-signatures">
<h2>Relation between types and signatures<a class="headerlink" href="#relation-between-types-and-signatures" title="Permalink to this headline">¶</a></h2>
<p>A type has a signature which is based on its kind and on some static
information (functions you can call on the <code class="xref cpp cpp-guess docutils literal"><span class="pre">TypeInterface</span></code> without a <code class="docutils literal"><span class="pre">void*</span></code>
pointer). For example, a value that contains a string would have a kind
<em>String</em> and a signature <code class="docutils literal"><span class="pre">&quot;s&quot;</span></code>.</p>
<p>This is not based uniquely on the kind. For example, the signatures <code class="docutils literal"><span class="pre">&quot;i&quot;</span></code> and
<code class="docutils literal"><span class="pre">&quot;I&quot;</span></code> both represent a kind <em>Integer</em> but one is signed and the other is
unsigned. There exist also different signatures for different integer sizes.</p>
<p>Tuples are represented by parenthesis, for example <code class="docutils literal"><span class="pre">&quot;(sis)&quot;</span></code> is a tuple of
<em>String</em>, <em>Integer</em> and <em>String</em>.</p>
<p>Lists are represented by square brackets, for example <code class="docutils literal"><span class="pre">&quot;[f]&quot;</span></code> is a list of
<em>Float</em>. It is invalid to put more than one type inside the brackets.</p>
</div>
<div class="section" id="value-s-states">
<h2>Value&#8217;s states<a class="headerlink" href="#value-s-states" title="Permalink to this headline">¶</a></h2>
<p>A value can be invalid (for example when it is not initialized). An invalid
value must never be used. Even though it looks like a <strong>Void</strong> value, it is not,
and lot of functions will throw (or crash?) with an invalid value.</p>
<p>A value can be of <em>Void</em> kind. This corresponds to &#8220;no-value&#8221;. It has no
equivalent in C++ but it works like Python&#8217;s None. You can instantiate such a
value in C++ though:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">qi</span><span class="o">::</span><span class="n">AnyValue</span> <span class="n">value</span><span class="p">(</span><span class="n">qi</span><span class="o">::</span><span class="n">typeOf</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="implementing-type-interfaces">
<h2>Implementing type interfaces<a class="headerlink" href="#implementing-type-interfaces" title="Permalink to this headline">¶</a></h2>
<p>Type interfaces must implement functions that receive a <code class="docutils literal"><span class="pre">void*</span></code> and must do
the action on it. For example <code class="xref cpp cpp-guess docutils literal"><span class="pre">IntTypeInterface::get</span></code> has the following
interface and possible implementation:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">int64_t</span> <span class="n">Int64TypeInterface</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">storage</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="kt">int64_t</span><span class="o">*</span><span class="p">)</span><span class="n">ptrFromStorage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">storage</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>These basic types for c++ are registered in the file <strong>registration.cpp</strong>. Note
that the function may not be that trivial, for example for Python:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">int64_t</span> <span class="n">PyLongTypeInterface</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">storage</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">PyLong_GetLong</span><span class="p">((</span><span class="n">PyObject</span><span class="o">*</span><span class="p">)</span><span class="n">ptrFromStorage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">storage</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This last function is implemented in <strong>pyobjectconvert.cpp</strong>.</p>
<p>Consider that <code class="docutils literal"><span class="pre">ptrFromStorage(&amp;storage)</span></code> returns <code class="docutils literal"><span class="pre">storage</span></code>. For more
information about this function, read the
<a class="reference internal" href="#internal-typesystem-pointervalue"><span>Pointer as pointer and pointer as value</span></a> section below.</p>
</div>
<div class="section" id="what-functions-a-type-interface-must-implement">
<h2>What functions a type interface must implement<a class="headerlink" href="#what-functions-a-type-interface-must-implement" title="Permalink to this headline">¶</a></h2>
<p>A basic type interface must implement some basic functions. You can see the
pure virtual functions in <code class="xref cpp cpp-guess docutils literal"><span class="pre">TypeInterface</span></code> in <strong>detail/typeinterface.hpp</strong>.</p>
<p>These functions include default construction, copying, destruction and a
less-than comparison operator. If default construction or copy is not possible,
these functions are allowed to throw. In general, any function is allowed to
throw if the operation is impossible. For example, lots of <code class="docutils literal"><span class="pre">set</span></code> throw in our
Python type interfaces because Python values are usually immutable.</p>
<p>The <code class="docutils literal"><span class="pre">less</span></code> function is used to compare objects when they are stored in a
container that need such a function to sort the items.</p>
<p>These functions are usually implemented through default implementations. Most
(all?) type interfaces declare an alias to a class with default implementation
and use a macro to bounce functions to it. For example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">using</span> <span class="n">Methods</span> <span class="o">=</span> <span class="n">qi</span><span class="o">::</span><span class="n">DefaultTypeImplMethods</span><span class="o">&lt;</span><span class="n">YourType</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">_QI_BOUNCE_TYPE_METHODS</span><span class="p">(</span><span class="n">Methods</span><span class="p">);</span>
</pre></div>
</div>
<p>There are macros that bounce only some methods so that you can implement the
others yourself.</p>
<p>The <code class="docutils literal"><span class="pre">DefaultTypeImplMethods</span></code> class lies in <strong>typeimpl.hxx</strong>.</p>
</div>
<div class="section" id="pointer-as-pointer-and-pointer-as-value">
<span id="internal-typesystem-pointervalue"></span><h2>Pointer as pointer and pointer as value<a class="headerlink" href="#pointer-as-pointer-and-pointer-as-value" title="Permalink to this headline">¶</a></h2>
<p>It is possible to apply an optimization so that when the type is small enough,
instead of storing a pointer to it in the <code class="docutils literal"><span class="pre">void*</span></code> storage, you store the value
itself. This is commonly called <em>small buffer optimization</em>. For example, you
would have a value with an <code class="xref cpp cpp-guess docutils literal"><span class="pre">IntTypeInterface</span></code> and a <code class="docutils literal"><span class="pre">void*</span></code> that would not be
a <code class="docutils literal"><span class="pre">int*</span></code> pointing to a value of 42, but a <code class="docutils literal"><span class="pre">void*</span></code> that holds the value 42
itself (and must not be dereferenced of course).</p>
<p>This optimization is actually not enabled for integers and is usually not a
good idea. This means that the following code would not have the expected
behavior:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">qi</span><span class="o">::</span><span class="n">AnyReference</span><span class="o">::</span><span class="n">from</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="n">ref</span><span class="p">.</span><span class="n">setInt</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">10</span><span class="p">);</span>
</pre></div>
</div>
<p>You can see the code used to implement this optimization commented out in
<strong>type.hxx</strong>, in the class <code class="docutils literal"><span class="pre">TypeImplMethodsBySize</span></code>. This class is actually
only used for the C++ <code class="docutils literal"><span class="pre">IntTypeInterface</span></code> in <strong>inttypeinterface.hxx</strong>.</p>
<p>It is enabled though on all pointer types. It seems safe enough and this
optimization relied upon in function type erasure, implemented in
<strong>anyfunctionfactory.hxx</strong>.</p>
<p>Anyway, the behavior of your type interface depends on the behavior of the
<code class="docutils literal"><span class="pre">ptrFromStorage</span></code> function. This function must return a <code class="docutils literal"><span class="pre">void*</span></code>. The only two
possible implementation (that make sense) are the following:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span><span class="o">*</span> <span class="nf">ptrFromStorage</span><span class="p">(</span><span class="kt">void</span><span class="o">**</span> <span class="n">storage</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="o">*</span><span class="n">storage</span><span class="p">;</span> <span class="c1">// use value as value</span>
  <span class="c1">// OR</span>
  <span class="k">return</span> <span class="n">storage</span><span class="p">;</span> <span class="c1">// use pointer as value</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As said before, any function accessing the <code class="docutils literal"><span class="pre">void*</span> <span class="pre">storage</span></code> or <code class="docutils literal"><span class="pre">void**</span>
<span class="pre">storage</span></code> must call this function. This is also why setter functions receive a
<code class="docutils literal"><span class="pre">void**</span></code> instead of a <code class="docutils literal"><span class="pre">void*</span></code>, it allows the setter to change the pointer
itself.</p>
<p>You can have a default implementation for this method too through the
<code class="docutils literal"><span class="pre">DefaultTypeImplMethods</span></code> class. You configure its behavior through the second
template argument you give it, which defaults to <code class="docutils literal"><span class="pre">TypeByPointer&lt;T&gt;</span></code> and is
the expected behavior. If you want to use the other behavior, use
<code class="docutils literal"><span class="pre">TypeByValue&lt;T&gt;</span></code>.</p>
</div>
<div class="section" id="construction-destruction-cloning">
<span id="internal-typesystem-typemanager"></span><h2>Construction, destruction, cloning<a class="headerlink" href="#construction-destruction-cloning" title="Permalink to this headline">¶</a></h2>
<p>It is possible to change the behavior of the <code class="docutils literal"><span class="pre">ptrFromStorage</span></code> method, with the
default construction method, cloning method, etc, by changing the second
argument you give to <code class="docutils literal"><span class="pre">TypeByPointer</span></code>, for types that are non-copyable or
non-default constructible. You can specify that for <code class="docutils literal"><span class="pre">TypeByValue</span></code>, the type
will have default construction and default copy.</p>
<p>The second argument to <code class="docutils literal"><span class="pre">TypeByPointer</span></code> is a <code class="docutils literal"><span class="pre">TypeManager</span></code> which has an
implementation for these functions. This <code class="docutils literal"><span class="pre">TypeManager</span></code> can be specialized and
has a default implementation which allows the user to specify what is possible
to do with their types thanks to some macros.</p>
<p>By default, the <code class="docutils literal"><span class="pre">TypeManager</span></code> makes default-constructible and copyable types
for PODs, and non-default-constructible and non-copyable types for the rest, as
can be seen in <strong>typeimpl.hxx</strong>.</p>
<p>It is possible to use the macros declared in <strong>typeinterface.hpp</strong> to
specialize <code class="docutils literal"><span class="pre">TypeManager</span></code> to declare that a type (that may or may not be known
to the type system, see <em>Unknown</em> kinds above) is or is not
default-constructible or copyable.</p>
<p>If an attempt is made to default-construct a type that is
non-default-constructible or to copy a type that is non-copyable, the
corresponding function will just throw.</p>
<p>Finally, there is the <code class="docutils literal"><span class="pre">TypeByPointerPOD</span></code> access which forces
default-constructibility and copyability.</p>
</div>
<div class="section" id="how-types-are-retrieved">
<h2>How types are retrieved<a class="headerlink" href="#how-types-are-retrieved" title="Permalink to this headline">¶</a></h2>
<p>You will reach a moment when the type system will receive a C++ object and will
need to know its <code class="xref cpp cpp-guess docutils literal"><span class="pre">TypeInterface</span></code>. This happens for example:</p>
<ul class="simple">
<li>when a struct is registered, the type system needs to know the type
interfaces of the underlying fields,</li>
<li>when an object&#8217;s method is registered, libqi needs the type interface of the
parameters and return value</li>
<li>when you use qi::typeOf&lt;T&gt;()</li>
<li>when you use <a class="reference internal" href="../api/cpp/type/anyvalue.html#qi::AnyValue::from__TCR" title="qi::AnyValue::from"><code class="xref cpp cpp-guess docutils literal"><span class="pre">qi::AnyValue::from</span></code></a>, which uses qi::TypeOf&lt;T&gt;</li>
</ul>
<p>It will first search through a static map to find if the type has been
registered at runtime. This part is done in <strong>typeinterface.cpp</strong> in the
function <code class="docutils literal"><span class="pre">getType</span></code>.</p>
<p>If the type is unknown to the type system yet, it will instantiate
<code class="docutils literal"><span class="pre">TypeImpl&lt;T&gt;</span></code> and use that. This part happens in <strong>type.hxx</strong>, in the
function <code class="docutils literal"><span class="pre">typeOfBackend</span></code>.</p>
</div>
<div class="section" id="how-types-are-registered">
<span id="internal-typesystem-register"></span><h2>How types are registered<a class="headerlink" href="#how-types-are-registered" title="Permalink to this headline">¶</a></h2>
<p>This section is tightly tied to the previous one, be sure to read it first.</p>
<p>To register something in the global map, you usually use the function
<code class="xref cpp cpp-guess docutils literal"><span class="pre">qi::registerType</span></code> in <strong>typeinterface.cpp</strong>.</p>
<p>The other way to &#8220;register&#8221; a type is to specialize the <code class="docutils literal"><span class="pre">qi::TypeImpl</span></code> class.
This may be useful to register full classes of types with C++ partial
specialization. For example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">StdVectorTypeInterface</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ListTypeInterface</span>
<span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">TypeImpl</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="o">:</span> <span class="k">public</span> <span class="n">StdVectorTypeInterface</span>
<span class="p">{};</span>
</pre></div>
</div>
<p>The type interface of std::vector is implemented in <strong>listtypeinterface.hxx</strong>.</p>
<p>If you need to register a template class, this is the only way to make it work
for any type T.</p>
<p>The default implementation of <code class="docutils literal"><span class="pre">TypeImpl&lt;T&gt;</span></code> is a type interface of <em>Unknown</em>
kind which uses <code class="docutils literal"><span class="pre">DefaultTypeImplMethods</span></code> with default values to implement its
methods. This means that it is configurable through the macros described in
<a class="reference internal" href="#internal-typesystem-typemanager"><span>Construction, destruction, cloning</span></a>.</p>
</div>
<div class="section" id="about-type-info-comparison">
<h2>About type_info comparison<a class="headerlink" href="#about-type-info-comparison" title="Permalink to this headline">¶</a></h2>
<p>To know if two types are equal, the type system uses simple <code class="docutils literal"><span class="pre">type_info</span></code>
comparison. This feature is very weakly defined by C++, especially when shared
libraries are used.</p>
<p>It is very important that the symbols of the type interfaces are exported in
shared libraries so that the <code class="docutils literal"><span class="pre">type_info</span></code> themselves are exported and the
runtime library can identify that two same types from different binaries are in
fact the same.</p>
<p>Mac&#8217;s compiler has a very strict policy about that, so there is a hack where
<code class="docutils literal"><span class="pre">type_info</span></code> are compared by mangled string representation instead of by value
under Apple systems. This hack is found in <strong>typeinterface.cpp</strong>.</p>
<p>If someday, libqi stops using plain <code class="docutils literal"><span class="pre">std::type_info</span></code> and uses
Boost.TypeIndex, this by-string-comparison behavior will be enforced on all
platforms.</p>
</div>
<div class="section" id="anyvalue-and-anyreference">
<h2>AnyValue and AnyReference<a class="headerlink" href="#anyvalue-and-anyreference" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="../api/cpp/type/anyvalue.html#qi::AnyValue" title="qi::AnyValue"><code class="xref cpp cpp-guess docutils literal"><span class="pre">AnyValue</span></code></a> has value semantic and <code class="xref cpp cpp-guess docutils literal"><span class="pre">AnyReference</span></code> has pointer semantic.
<code class="xref cpp cpp-guess docutils literal"><span class="pre">AnyReference</span></code> never frees its value (unless <code class="docutils literal"><span class="pre">destroy()</span></code> is explicitly
called). <a class="reference internal" href="../api/cpp/type/anyvalue.html#qi::AnyValue" title="qi::AnyValue"><code class="xref cpp cpp-guess docutils literal"><span class="pre">AnyValue</span></code></a> usually owns its value and frees it automatically at
destruction. It doesn&#8217;t own it sometimes, depending on the arguments given at
its construction.</p>
<p>Users should always use <a class="reference internal" href="../api/cpp/type/anyvalue.html#qi::AnyValue" title="qi::AnyValue"><code class="xref cpp cpp-guess docutils literal"><span class="pre">AnyValue</span></code></a>, <code class="xref cpp cpp-guess docutils literal"><span class="pre">AnyReference</span></code> is usually for internal use.</p>
<p>Be careful when using <code class="xref cpp cpp-guess docutils literal"><span class="pre">AnyReference</span></code>, do not create reference to temporaries.
Your compiler won&#8217;t be able to detect it, you will not get a warning.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">qi</span><span class="o">::</span><span class="n">AnyReference</span><span class="o">::</span><span class="n">from</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// good</span>

<span class="n">ref</span> <span class="o">=</span> <span class="n">qi</span><span class="o">::</span><span class="n">AnyReference</span><span class="o">::</span><span class="n">from</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">python</span><span class="o">::</span><span class="n">object</span><span class="p">(</span><span class="n">i</span><span class="p">));</span> <span class="c1">// BAD</span>
<span class="k">auto</span> <span class="n">value</span> <span class="o">=</span> <span class="n">ref</span><span class="p">.</span><span class="n">toInt</span><span class="p">();</span> <span class="c1">// undefined behavior</span>
</pre></div>
</div>
</div>
</div>


              </div>
            </div>
          </div>
          
            
              <div class="yui-b" id="sidebar">
                
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../contents.html">Site map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../news/index.html">What’s new</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../../index_dev_guide.html">NAOqi - Developer guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../../getting_started/index.html">Getting Started</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../getting_started/creating_applications/index.html">Creating an application</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../ref/life/index.html">Programming for a living robot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../getting_started/index_tuto.html">Other tutorials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../software/choregraphe/index.html">Choregraphe Suite</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../programming_index.html">SDKs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../naoqi/index.html">NAOqi APIs</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">qi Framework</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../api/index.html">API References</a></li>
<li class="toctree-l3"><a class="reference internal" href="../guide/index.html">Hands-on Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../design/index.html">Design Documents</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="">Type system</a><ul class="simple">
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="object.html">Object type erasure</a></li>
<li class="toctree-l3"><a class="reference internal" href="template.html">Registering template types</a></li>
<li class="toctree-l3"><a class="reference internal" href="call.html">Call code path</a></li>
<li class="toctree-l3"><a class="reference internal" href="messaging.html">Messaging system</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changelog/index.html">qi Framework - ChangeLog</a></li>
<li class="toctree-l3"><a class="reference internal" href="../changelog/interface.html">qi Framework - Deprecation history</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../ref/index.html">Former NAOqi Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../simulators/simulator_index.html">Simulators</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../home_nao.html"><strong>NAO</strong> - Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../home_pepper.html"><strong>Pepper</strong> - Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../home_romeo.html"><strong>Romeo</strong> - Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../legal/notice.html">Legal notices</a></li>
</ul>

    <div id="on-this-page" style="display:none;">
        <h2 id="otp-link">On this page</h2>
        <div id="toc-list">
            <ul>
<li><a class="reference internal" href="#">Type system</a><ul>
<li><a class="reference internal" href="#about-kinds">About kinds</a></li>
<li><a class="reference internal" href="#relation-between-types-and-signatures">Relation between types and signatures</a></li>
<li><a class="reference internal" href="#value-s-states">Value&#8217;s states</a></li>
<li><a class="reference internal" href="#implementing-type-interfaces">Implementing type interfaces</a></li>
<li><a class="reference internal" href="#what-functions-a-type-interface-must-implement">What functions a type interface must implement</a></li>
<li><a class="reference internal" href="#pointer-as-pointer-and-pointer-as-value">Pointer as pointer and pointer as value</a></li>
<li><a class="reference internal" href="#construction-destruction-cloning">Construction, destruction, cloning</a></li>
<li><a class="reference internal" href="#how-types-are-retrieved">How types are retrieved</a></li>
<li><a class="reference internal" href="#how-types-are-registered">How types are registered</a></li>
<li><a class="reference internal" href="#about-type-info-comparison">About type_info comparison</a></li>
<li><a class="reference internal" href="#anyvalue-and-anyreference">AnyValue and AnyReference</a></li>
</ul>
</li>
</ul>

        </div>
    </div>
        </div>
      </div>
              </div>
            
          
        </div>
    </main>
    <a href="#0" class="cd-top"></a>
    <div id="ft">
      
      <a title="Glossary" href="../../../glossary.html">Glossary</a>
      <a title="Site map" href="../../../contents.html">Site map</a>
      <a title="Index" href="../../../genindex.html">Index</a>
      <a title="Support" target="_blank" href="https://account.aldebaran.com/support/">Support</a>
      <a title="Contact" target="_blank" href="https://www.aldebaran.com/en/contact">Contact</a>
      <a title="Legal Notices" href="../../../legal/notice.html">Legal Notices</a>
      
      
      <img src="https://www.ald.softbankrobotics.com/sites/aldebaran/files/logos-picture/2016_digital_logo_sbr_112x31_0.png" alt="">
    </div>
  </div>

      <div class="clearer"></div>
    </div>
  </body>
</html>